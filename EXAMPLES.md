
## Flags in tags:
Use flags in your types to create custom types. If there is an issue parsing a specific type, use the `tw` tag to create one on your own
#### Syntax: `tw:"<TypeName>,<PointerBool>"`

```go
type Data struct {
	SomeType ArbitraryType 	`json:"some_type" tw:"overrideType,true"`
}
```

```js
export type Data = {
	some_type: ?overrideType
}
```

____
## Flags in comments:
* `@strict` (flow only)
Set strict to true, making sure the flow object will have exactly these key/value pairs.
```go
// Data holds data
// @strict
type Data struct {
	SomeType ArbitraryType 	`json:"some_type" tw:"overrideType,true"`
}
```

```js
export type Data = {|
	some_type: ?overrideType
|}
```


* `@ignore`
Ignore this type while parsing your code
```go
// Data holds data
// @ignore
type Data struct {
	SomeType ArbitraryType 	`json:"some_type" tw:"overrideType,true"`
}
```
 will not parse

____
### Examples of compex Go types to other types:
Go types:
```go
package stubs

// Data should all parse right.
// It's hard to get them to do that.
// @strict
type Data struct {
	MapStringInt  map[string]int            `json:"map_string_to_int" tw:"override_map_name,false"`  // I am a map of strings and ints
	MapStringInts map[string][]int          `json:"map_string_to_ints"`                              // I am a map of strings to a slice of ints
	MapStringMap  map[string]map[string]int `json:"map_string_to_maps" tw:"override_map_name2,true"` // I am a map of strings to maps
	MapIgnore     map[int]int               `json:"-"`
	Peeps         People                    `json:"peeps"`
}

// Person ...
type Person struct {
	Name string `json:"name"`
	Age  int    `json:"age"`
}

// People is a map of strings to person
type People map[string]Person

// Nested defaults to the closest "Object" type in any language. Utilize the `tw` tag if needed.
type Nested struct {
	Person struct{} `json:"person"`
}

// Embedded will take all types from the embedded types and insert them in to the new type.
type Embedded struct {
	Person
}

```

To Flow Types:
```js
// @flow
// Automatically generated by typewriter. Do not edit.
// http://www.github.com/natdm/typewriter


// Data should all parse right.
// It's hard to get them to do that.
// @strict
export type Data = {| 
	map_string_to_int: override_map_name, // I am a map of strings and ints

	map_string_to_ints: { [key: string]: Array<number> }, // I am a map of strings to a slice of ints

	map_string_to_maps: ?override_map_name2, // I am a map of strings to maps

	peeps: People
|}

// Embedded will take all types from the embedded types and insert them in to the new type.
export type Embedded = { 
	name: string, 
	age: number
}

export type MyNumber = number

// Nested defaults to the closest "Object" type in any language. Utilize the `tw` tag if needed.
export type Nested = { 
	person: Object
}

// People is a map of strings to person
export type People = { [key: string]: Person }

// Person ...
export type Person = { 
	name: string, 
	age: number
}

export type Thing = { 
	name: number
}
```

To TypeScript types
```js
// Automatically generated by typewriter. Do not edit.
// http://www.github.com/natdm/typewriter


// Data should all parse right.
// It's hard to get them to do that.
// @strict
type Data = {
	map_string_to_int: override_map_name, // I am a map of strings and ints

	map_string_to_ints: { [key: string]: Array<number> }, // I am a map of strings to a slice of ints

	map_string_to_maps: ?override_map_name2, // I am a map of strings to maps

	peeps: People
}

// Embedded will take all types from the embedded types and insert them in to the new type.
type Embedded = {
	name: string, 
	age: number
}

type MyNumber = number

// Nested defaults to the closest "Object" type in any language. Utilize the `tw` tag if needed.
type Nested = {
	person: Object
}

// People is a map of strings to person
type People = { [key: string]: Person }

// Person ...
type Person = {
	name: string, 
	age: number
}

type Thing = {
	name: number
}

```

To Elm types (work in progress)
```elm
-- Automatically generated by typewriter. Do not edit.
-- http://www.github.com/natdm/typewriter


--Data should all parse right.
--It's hard to get them to do that.
--@strict
type alias Data : {
	map_string_to_int : override_map_name, --I am a map of strings and ints
	map_string_to_ints :Dict  String  List Int, --I am a map of strings to a slice of ints
	map_string_to_maps : override_map_name2, --I am a map of strings to maps
	peeps : People 
}

--Embedded will take all types from the embedded types and insert them in to the new type.
type alias Embedded : {
	name : String, 	age : Int 
}

type alias MyNumber :  Int

--Nested defaults to the closest "Object" type in any language. Utilize the `tw` tag if needed.
type alias Nested : {
	person : Maybe 
}

--People is a map of strings to person
type alias People : Dict  String  Person

--Person ...
type alias Person : {
	name : String, 	age : Int 
}

type alias Thing : {
	name : Int 
}

```
---

### Example use in a package like [Ponzu](https://github.com/ponzu-cms/ponzu):
`$ ponzu gen content review title:"string" body:"string" rating:"int" tags:"[]
string" && typewriter -file ./content/review.go -lang flow -out ./models.js`

Ponzu: 

```go
...

type Review struct {
	item.Item

	Title  string   `json:"title"`
	Body   string   `json:"body"`
	Rating int      `json:"rating"`
	Tags   []string `json:"tags"`
}

...
```

Typewriter generates:
```js
// @flow
// Automatically generated by typewriter. Do not edit.
// http://www.github.com/natdm/typewriter


export type Review = { 
	title: string, 
	body: string, 
	rating: number, 
	tags: Array<string>
}
```